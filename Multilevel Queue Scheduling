import heapq
import random
from collections import deque

class Process:
    def __init__(self, pid, arrival_time, burst_time, priority):
        self.pid = pid
        self.arrival_time = arrival_time
        self.burst_time = burst_time
        self.priority = priority
        self.remaining_time = burst_time
        self.completion_time = 0
        self.turnaround_time = 0
        self.waiting_time = 0

    def __lt__(self, other):
        return (self.priority, self.arrival_time) < (other.priority, other.arrival_time)

# Function to generate processes with random attributes
def generate_processes(num_processes):
    processes = []
    for i in range(num_processes):
        pid = i + 1
        arrival_time = random.randint(0, 10)  # Random arrival time
        burst_time = random.randint(1, 10)    # Random burst time
        priority = random.randint(1, 5)       # Random priority between 1 and 5
        processes.append(Process(pid, arrival_time, burst_time, priority))
    return processes

# High Priority Queue with Preemptive Priority Scheduling
def high_priority_queue(processes):
    processes.sort(key=lambda x: x.arrival_time)
    time = 0
    ready_queue = []
    completed_processes = []
    current_process = None

    while processes or ready_queue or current_process:
        while processes and processes[0].arrival_time <= time:
            heapq.heappush(ready_queue, processes.pop(0))

        if current_process and ready_queue and ready_queue[0].priority < current_process.priority:
            heapq.heappush(ready_queue, current_process)
            current_process = None

        if not current_process and ready_queue:
            current_process = heapq.heappop(ready_queue)

        if current_process:
            current_process.remaining_time -= 1
            time += 1
            if current_process.remaining_time == 0:
                current_process.completion_time = time
                current_process.turnaround_time = current_process.completion_time - current_process.arrival_time
                current_process.waiting_time = current_process.turnaround_time - current_process.burst_time
                completed_processes.append(current_process)
                current_process = None
        else:
            time += 1

    return completed_processes

# Medium Priority Queue with Round Robin Scheduling
def medium_priority_queue(processes, time_quantum):
    processes.sort(key=lambda x: x.arrival_time)
    time = 0
    ready_queue = deque()
    completed_processes = []

    while processes or ready_queue:
        while processes and processes[0].arrival_time <= time:
            ready_queue.append(processes.pop(0))  # Use pop(0) for lists

        if ready_queue:
            current_process = ready_queue.popleft()  # Still use popleft() for deque
            time_slice = min(current_process.remaining_time, time_quantum)
            time += time_slice
            current_process.remaining_time -= time_slice

            # Increment waiting time for other processes in the queue
            for process in ready_queue:
                process.waiting_time += time_slice

            if current_process.remaining_time == 0:
                current_process.completion_time = time
                current_process.turnaround_time = current_process.completion_time - current_process.arrival_time
                current_process.waiting_time = current_process.turnaround_time - current_process.burst_time
                completed_processes.append(current_process)
            else:
                ready_queue.append(current_process)  # Process not finished, re-queue
        else:
            time += 1

    return completed_processes

# Low Priority Queue with Non-Preemptive Priority Scheduling
def low_priority_queue(processes):
    processes.sort(key=lambda x: x.arrival_time)
    time = 0
    ready_queue = []
    completed_processes = []

    while processes or ready_queue:
        while processes and processes[0].arrival_time <= time:
            ready_queue.append(processes.pop(0))

        if ready_queue:
            current_process = ready_queue.pop(0)  # Use pop(0) for lists
            time += current_process.burst_time
            current_process.completion_time = time
            current_process.turnaround_time = current_process.completion_time - current_process.arrival_time
            current_process.waiting_time = current_process.turnaround_time - current_process.burst_time
            completed_processes.append(current_process)
        else:
            time += 1

    return completed_processes

# Function to run Multilevel Queue Scheduling
def multilevel_queue_scheduling(num_processes, time_quantum):
    processes = generate_processes(num_processes)

    print("\nGenerated Processes:")
    for p in processes:
        print(f"PID: {p.pid}, Arrival: {p.arrival_time}, Burst: {p.burst_time}, Priority: {p.priority}")

    # High Priority Queue
    print("\n--- High Priority Queue (Preemptive Priority Scheduling) ---")
    completed_hp = high_priority_queue(processes[:])
    for p in completed_hp:
        print(f"PID: {p.pid}, Completion Time: {p.completion_time}, Turnaround Time: {p.turnaround_time}, Waiting Time: {p.waiting_time}")

    # Medium Priority Queue
    print("\n--- Medium Priority Queue (Round Robin Scheduling) ---")
    completed_mp = medium_priority_queue(processes[:], time_quantum)
    for p in completed_mp:
        print(f"PID: {p.pid}, Completion Time: {p.completion_time}, Turnaround Time: {p.turnaround_time}, Waiting Time: {p.waiting_time}")

    # Low Priority Queue
    print("\n--- Low Priority Queue (Non-Preemptive Priority Scheduling) ---")
    completed_lp = low_priority_queue(processes[:])
    for p in completed_lp:
        print(f"PID: {p.pid}, Completion Time: {p.completion_time}, Turnaround Time: {p.turnaround_time}, Waiting Time: {p.waiting_time}")

# Run the Multilevel Queue Scheduling with 5 processes and a time quantum of 2
multilevel_queue_scheduling(5, 2)

