import random
import heapq


# Process class to store process information
class Process:
    def __init__(self, pid, arrival_time, burst_time):
        self.pid = pid
        self.arrival_time = arrival_time
        self.burst_time = burst_time
        self.remaining_time = burst_time
        self.start_time = -1
        self.completion_time = 0
        self.turnaround_time = 0
        self.waiting_time = 0


# Generate random processes
def generate_processes(num_processes):
    processes = []
    for i in range(num_processes):
        arrival_time = random.randint(0, 20)  # Random arrival time between 0 and 20 ms
        burst_time = random.randint(1, 10)  # Random burst time between 1 and 10 ms
        processes.append(Process(i + 1, arrival_time, burst_time))
    return processes


# Non-Preemptive SJF
def non_preemptive_sjf(processes):
    processes.sort(key=lambda p: p.arrival_time)  # Sort by arrival time
    current_time = 0
    completed_processes = []
    ready_queue = []

    while len(completed_processes) < len(processes):
        # Add arrived processes to ready queue
        for process in processes:
            if process.arrival_time <= current_time and process not in ready_queue and process not in completed_processes:
                ready_queue.append(process)

        if ready_queue:
            # Select the process with the shortest burst time
            ready_queue.sort(key=lambda p: p.burst_time)
            current_process = ready_queue.pop(0)

            if current_process.start_time == -1:
                current_process.start_time = current_time

            current_time += current_process.burst_time
            current_process.completion_time = current_time
            current_process.turnaround_time = current_process.completion_time - current_process.arrival_time
            current_process.waiting_time = current_process.turnaround_time - current_process.burst_time
            completed_processes.append(current_process)
        else:
            current_time += 1

    return completed_processes


# Preemptive SJF (Shortest Remaining Time First - SRTF)
def preemptive_sjf(processes):
    processes.sort(key=lambda p: p.arrival_time)
    ready_queue = []
    current_time = 0
    completed_processes = []
    current_process = None

    while len(completed_processes) < len(processes):
        # Add arrived processes to ready queue
        for process in processes:
            if process.arrival_time == current_time and process not in ready_queue and process not in completed_processes:
                heapq.heappush(ready_queue, (process.remaining_time, process.pid, process))

        if current_process:
            if current_process.remaining_time > 0:
                heapq.heappush(ready_queue, (current_process.remaining_time, current_process.pid, current_process))

        # Select the process with the shortest remaining time
        if ready_queue:
            current_process = heapq.heappop(ready_queue)[2]  # The process object is in the 3rd position of the tuple
            if current_process.start_time == -1:
                current_process.start_time = current_time
            current_process.remaining_time -= 1

            if current_process.remaining_time == 0:
                current_process.completion_time = current_time + 1
                current_process.turnaround_time = current_process.completion_time - current_process.arrival_time
                current_process.waiting_time = current_process.turnaround_time - current_process.burst_time
                completed_processes.append(current_process)
                current_process = None

        current_time += 1

    return completed_processes


# Calculate Performance Metrics
def calculate_metrics(processes):
    total_turnaround_time = sum([p.turnaround_time for p in processes])
    total_waiting_time = sum([p.waiting_time for p in processes])
    current_time = max([p.completion_time for p in processes])

    avg_turnaround_time = total_turnaround_time / len(processes)
    avg_waiting_time = total_waiting_time / len(processes)
    cpu_utilization = (sum([p.burst_time for p in processes]) / current_time) * 100
    throughput = len(processes) / current_time

    return avg_turnaround_time, avg_waiting_time, cpu_utilization, throughput


# Display the process details and performance metrics
def display_results(processes, title):
    print(f"\n{title}")
    print(f"{'PID':<5}{'Arrival':<10}{'Burst':<10}{'Start':<10}{'Completion':<15}{'Turnaround':<15}{'Waiting':<10}")
    for process in processes:
        print(
            f"{process.pid:<5}{process.arrival_time:<10}{process.burst_time:<10}{process.start_time:<10}{process.completion_time:<15}{process.turnaround_time:<15}{process.waiting_time:<10}")

    avg_turnaround_time, avg_waiting_time, cpu_utilization, throughput = calculate_metrics(processes)
    print(f"\nPerformance Metrics:")
    print(f"Average Turnaround Time: {avg_turnaround_time:.2f} ms")
    print(f"Average Waiting Time: {avg_waiting_time:.2f} ms")
    print(f"CPU Utilization: {cpu_utilization:.2f}%")
    print(f"Throughput: {throughput:.2f} processes/ms")


# Main function to simulate scheduling algorithms
def main():
    num_processes = 20
    processes = generate_processes(num_processes)

    # Non-Preemptive SJF
    np_sjf_processes = non_preemptive_sjf(processes.copy())
    display_results(np_sjf_processes, "Non-Preemptive Shortest Job First (SJF)")

    # Preemptive SJF (SRTF)
    p_sjf_processes = preemptive_sjf(processes.copy())
    display_results(p_sjf_processes, "Preemptive Shortest Job First (SRTF)")


if __name__ == "__main__":
    main()
