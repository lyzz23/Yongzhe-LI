import heapq
import random


class Process:
    def __init__(self, pid, arrival_time, burst_time, priority):
        self.pid = pid
        self.arrival_time = arrival_time
        self.burst_time = burst_time
        self.priority = priority  # Priority of the process
        self.remaining_time = burst_time  # For preemptive scheduling
        self.completion_time = 0
        self.turnaround_time = 0
        self.waiting_time = 0

    def __lt__(self, other):
        # Sort by priority, if priority is the same, sort by arrival time
        return (self.priority, self.arrival_time) < (other.priority, other.arrival_time)


# Function to generate processes with random attributes
def generate_processes(num_processes):
    processes = []
    for i in range(num_processes):
        pid = i + 1
        arrival_time = random.randint(0, 10)  # Random arrival time
        burst_time = random.randint(1, 10)  # Random burst time
        priority = random.randint(1, 5)  # Random priority between 1 and 5
        processes.append(Process(pid, arrival_time, burst_time, priority))
    return processes


# Non-Preemptive Priority Scheduling
def non_preemptive_priority_scheduling(processes):
    # Sort processes first by arrival time
    processes.sort(key=lambda x: x.arrival_time)
    time = 0
    ready_queue = []
    completed_processes = []

    while processes or ready_queue:
        # Add all processes that have arrived by the current time to the ready queue
        while processes and processes[0].arrival_time <= time:
            heapq.heappush(ready_queue, processes.pop(0))

        if ready_queue:
            # Get the highest priority process (min-heap)
            current_process = heapq.heappop(ready_queue)
            # Process runs to completion in non-preemptive
            time += current_process.burst_time
            current_process.completion_time = time
            current_process.turnaround_time = current_process.completion_time - current_process.arrival_time
            current_process.waiting_time = current_process.turnaround_time - current_process.burst_time
            completed_processes.append(current_process)
        else:
            time += 1  # If no process is ready, advance time

    return completed_processes


# Preemptive Priority Scheduling
def preemptive_priority_scheduling(processes):
    processes.sort(key=lambda x: x.arrival_time)  # Sort by arrival time initially
    time = 0
    ready_queue = []
    completed_processes = []
    current_process = None

    while processes or ready_queue or current_process:
        # Add all processes that have arrived by the current time to the ready queue
        while processes and processes[0].arrival_time <= time:
            heapq.heappush(ready_queue, processes.pop(0))

        # Check if there is a process in the ready queue that has higher priority than the current process
        if current_process and ready_queue and ready_queue[0].priority < current_process.priority:
            heapq.heappush(ready_queue, current_process)  # Preempt current process
            current_process = None

        if not current_process and ready_queue:
            # Get the highest priority process (min-heap)
            current_process = heapq.heappop(ready_queue)

        if current_process:
            current_process.remaining_time -= 1
            time += 1
            if current_process.remaining_time == 0:  # Process completes
                current_process.completion_time = time
                current_process.turnaround_time = current_process.completion_time - current_process.arrival_time
                current_process.waiting_time = current_process.turnaround_time - current_process.burst_time
                completed_processes.append(current_process)
                current_process = None
        else:
            time += 1  # If no process is ready, advance time

    return completed_processes


# Function to calculate average waiting time and turnaround time
def calculate_metrics(completed_processes):
    total_turnaround_time = sum(p.turnaround_time for p in completed_processes)
    total_waiting_time = sum(p.waiting_time for p in completed_processes)
    n = len(completed_processes)

    avg_turnaround_time = total_turnaround_time / n
    avg_waiting_time = total_waiting_time / n

    return avg_turnaround_time, avg_waiting_time


# Simulate and print results
def simulate_priority_scheduling(num_processes):
    processes = generate_processes(num_processes)

    print("\nGenerated Processes:")
    for p in processes:
        print(f"PID: {p.pid}, Arrival: {p.arrival_time}, Burst: {p.burst_time}, Priority: {p.priority}")

    # Non-Preemptive Priority Scheduling
    print("\n--- Non-Preemptive Priority Scheduling ---")
    completed_np = non_preemptive_priority_scheduling(processes[:])
    avg_turnaround_np, avg_waiting_np = calculate_metrics(completed_np)

    for p in completed_np:
        print(f"PID: {p.pid}, Turnaround Time: {p.turnaround_time}, Waiting Time: {p.waiting_time}")
    print(f"Average Turnaround Time: {avg_turnaround_np}, Average Waiting Time: {avg_waiting_np}")

    # Preemptive Priority Scheduling
    print("\n--- Preemptive Priority Scheduling ---")
    completed_p = preemptive_priority_scheduling(processes[:])
    avg_turnaround_p, avg_waiting_p = calculate_metrics(completed_p)

    for p in completed_p:
        print(f"PID: {p.pid}, Turnaround Time: {p.turnaround_time}, Waiting Time: {p.waiting_time}")
    print(f"Average Turnaround Time: {avg_turnaround_p}, Average Waiting Time: {avg_waiting_p}")


# Run the simulation with 5 processes
simulate_priority_scheduling(5)
